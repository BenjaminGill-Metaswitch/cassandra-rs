use std::fmt::{Debug, Display, Formatter};
use std::{fmt, mem, slice, str};
use std::ffi::{CStr, CString, NulError};
use std::error::Error;
use std::net::AddrParseError;

use cassandra_sys::CASS_OK;
use cassandra_sys::cass_error_desc;
use cassandra_sys::cass_error_num_arg_types;
use cassandra_sys::cass_error_result_arg_type;
use cassandra_sys::cass_error_result_code;
use cassandra_sys::cass_error_result_consistency;
use cassandra_sys::cass_error_result_data_present;
use cassandra_sys::cass_error_result_free;
use cassandra_sys::cass_error_result_function;
use cassandra_sys::cass_error_result_keyspace;
use cassandra_sys::cass_error_result_num_failures;
use cassandra_sys::cass_error_result_responses_received;
use cassandra_sys::cass_error_result_responses_required;
use cassandra_sys::cass_error_result_table;
use cassandra_sys::cass_error_result_write_type;

use cassandra::consistency::Consistency;
use cassandra::write_type::WriteType;
use cassandra_sys::CassError as _CassError;
use cassandra::consistency;
use cassandra::util::Protected;

use cassandra_sys::CassErrorResult as _CassErrorResult;

// #[repr(C)]
// //Upstream Cassandra errors can cone from multiple portions of the code, including both client and server code
// pub enum CassErrorSource {
//    ///No known source FIXME not sure if ever used
//    NONE = 0isize,
//    ///Error messages originating from the C++ driver code
//    LIB = 1,
//    ///Error messages originating from the Cassandra server
//    SERVER = 2,
//    ///Error messages originating from the SSL library linked from the client
//    SSL = 3,
//    ///Error message originating from the compression libraries linked from the client
//    COMPRESSION = 4,
// }

///These are Rust errors that are wrapped so that all errors returned by this driver can
///fall under the umbrella of CassError
pub enum CassRustError {
    ///NulErrors should only occur when you pass a string containing an internal null to
    ///to the driver code. The driver converts these to CStrings to use FFI to call out to
    ///the C++ driver, and C strings can't contain nulls. Don't do that.
    NulInString(NulError),
    ///Should only occur if you pass an invalidly formatted IP address string to the driver
    BadAddress(AddrParseError),
}

// ///All types of errors that this driver can return
//pub enum CassError {
//    ///An error signaled by the C++ driver
//    Lib(CassLibError),
//    ///An error signaled by the server and sent to the client over CQL transport
//    Server(CassServerError),
//    ///An error signaled by the client-linked SSL library
//    Ssl(CassSslError),
//    ///An error generated within rust code directly
//    Rust(CassRustError),
//}

pub struct CassError(_CassError);

// ///An error generated by the C++ driver
//pub struct CassLibError {
//    err: _CassError,
//    msg: String,
//}

// ///An error signaled by the server and sent to the client over CQL transport
//pub struct CassServerError(_CassError);
// ///An error signaled by the client-linked SSL library
// pub struct CassSslError(_CassError);

impl Error for CassError {
    fn description(&self) -> &str {
        self.desc()
        // let c_buf: *const i8 = self.desc();
        // let buf: &[u8] = unsafe { CStr::from_ptr(c_buf).to_bytes() };
        // from_utf8(buf).unwrap()
    }
}

//impl From<AddrParseError> for CassError {
//    fn from(err: AddrParseError) -> CassError {
//        CassError::Rust(CassRustError::BadAddress(err))
//    }
//}

//impl From<NulError> for CassError {
//    fn from(err: NulError) -> CassError {
//        CassError::Rust(CassRustError::NulInString(err))
//    }
//}

impl Display for CassError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "{}", self.desc())
        //        let c_buf: *const i8 = self.desc();
        //        let buf: &[u8] = unsafe { CStr::from_ptr(c_buf).to_bytes() };
        //        match str::from_utf8(buf) {
        //            Ok(str_slice) => write!(f, "{}", str_slice),
        //            Err(err) => panic!("unreachable? {:?}", err),
        //        }
    }
}

impl Debug for CassError {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        write!(f, "{}", self.desc())
        //        let c_buf: *const i8 = self.desc();
        //        let buf: &[u8] = unsafe { CStr::from_ptr(c_buf).to_bytes() };
        //        match str::from_utf8(buf) {
        //            Ok(str_slice) => write!(f, "{:?}", str_slice),
        //            Err(err) => panic!("unreachable? {:?}", err),
        //        }
    }
}

// impl From<NulError> for CassError {
//    fn from(err: NulError) -> CassError {
//        CliError::Io(err)
//    }
// }

impl CassError {
///Takes an upstream error and wraps it into the appropriate CassError
 pub fn wrap<T>(self, wrappee: T) -> Result<T, CassError> {
 	match self.0 {
                    CASS_OK => Ok(wrappee),
                    err => Err(CassError::build(err)),
                }
 }
	//
}
///An error result of a request
pub struct CassErrorResult(*const _CassErrorResult);

impl Protected<*const _CassErrorResult> for CassErrorResult {
    fn inner(&self) -> *const _CassErrorResult {
        self.0
    }
    fn build(inner: *const _CassErrorResult) -> Self {
        CassErrorResult(inner)
    }
}

impl Protected<_CassError> for CassError {
    fn inner(&self) -> _CassError {
       self.0
    }
    fn build (inner: _CassError) -> Self {
        CassError(inner)
    }
}

impl CassErrorResult {
    ///Gets error code for the error result. This error code will always
    ///have an server error source.
    pub fn result_code(&self) -> u32 {
        unsafe { cass_error_result_code(self.0) as u32 }
    }

    ///Gets consistency that triggered the error result of the
    ///following types:
    ///
    ///<ul>
    ///  <li>CASS_ERROR_SERVER_READ_TIMEOUT</li>
    ///  <li>CASS_ERROR_SERVER_WRITE_TIMEOUT</li>
    ///  <li>CASS_ERROR_SERVER_READ_FAILURE</li>
    ///  <li>CASS_ERROR_SERVER_WRITE_FAILURE</li>
    ///  <li>CASS_ERROR_SERVER_UNAVAILABLE</li>
    /// </ul>
    pub fn result_consistency(&self) -> Consistency {
        unsafe { Consistency::build(cass_error_result_consistency(self.0)) }
    }

    /// Gets the actual number of received responses, received acknowledgments
    ///or alive nodes for following error result types, respectively:
    ///
    ///<ul>
    ///  <li>CASS_ERROR_SERVER_READ_TIMEOUT</li>
    ///   <li>CASS_ERROR_SERVER_WRITE_TIMEOUT</li>
    ///   <li>CASS_ERROR_SERVER_READ_FAILURE</li>
    ///   <li>CASS_ERROR_SERVER_WRITE_FAILURE</li>
    ///   <li>CASS_ERROR_SERVER_UNAVAILABLE</li>
    /// </ul>
    pub fn responses_received(&self) -> i32 {
        unsafe { cass_error_result_responses_received(self.0) }
    }

    /// Gets required responses, required acknowledgments or required alive nodes
    ///needed to successfully complete the request for following error result types,
    ///respectively:
    ///
    ///<ul>
    ///  <li>CASS_ERROR_SERVER_READ_TIMEOUT</li>
    ///   <li>CASS_ERROR_SERVER_WRITE_TIMEOUT</li>
    ///   <li>CASS_ERROR_SERVER_READ_FAILURE</li>
    ///   <li>CASS_ERROR_SERVER_WRITE_FAILURE</li>
    ///   <li>CASS_ERROR_SERVER_UNAVAILABLE</li>
    /// </ul>
    pub fn responses_required(&self) -> i32 {
        unsafe { cass_error_result_responses_required(self.0) }
    }

    ///Gets the number of nodes that experienced failures for the following error types:
    ///
    ///<ul>
    ///   <li>CASS_ERROR_SERVER_READ_FAILURE</li>
    ///   <li>CASS_ERROR_SERVER_WRITE_FAILURE</li>
    /// </ul>
    pub fn num_failures(&self) -> i32 {
        unsafe { cass_error_result_num_failures(self.0) }
    }

    ///Determines whether the actual data was present in the responses from the
    ///replicas for the following error result types:
    ///
    /// <ul>
    ///   <li>CASS_ERROR_SERVER_READ_TIMEOUT</li>
    ///   <li>CASS_ERROR_SERVER_READ_FAILURE</li>
    /// </ul>
    pub fn data_present(&self) -> bool {
        unsafe { cass_error_result_data_present(self.0) as i32 > 0 }
    }


    ///Gets the write type of a request for the following error result types:
    ///
    /// <ul>
    ///   <li>CASS_ERROR_SERVER_WRITE_TIMEOUT</li>
    ///   <li>CASS_ERROR_SERVER_WRITE_FAILURE</li>
    /// </ul>
    pub fn write_type(&self) -> WriteType {
        unsafe { WriteType(cass_error_result_write_type(self.0)) }
    }

    ///Gets the affected keyspace for the following error result types:
    ///
    /// <ul>
    ///   <li>CASS_ERROR_SERVER_ALREADY_EXISTS</li>
    ///   <li>CASS_ERROR_SERVER_FUNCTION_FAILURE</li>
    ///</ul>
    pub fn keyspace(&self) -> String {
        unsafe {
            let mut name = mem::zeroed();
            let mut length = mem::zeroed();
            match cass_error_result_keyspace(self.0, &mut name, &mut length) {
                CASS_OK => {
                    let slice = slice::from_raw_parts(name as *const u8, length as usize);
                    str::from_utf8(slice).unwrap().to_owned()
                }
                err => panic!("impossible: {:?}", err),
            }
        }
    }

    ///Gets the affected table for the already exists error
    ///(CASS_ERROR_SERVER_ALREADY_EXISTS) result type.
    pub fn table(&self) -> String {
        unsafe {
            let mut name = mem::zeroed();
            let mut length = mem::zeroed();
            match cass_error_result_table(self.0, &mut name, &mut length) {
                CASS_OK => {
                    let slice = slice::from_raw_parts(name as *const u8, length as usize);
                    str::from_utf8(slice).unwrap().to_owned()
                }
                err => panic!("impossible: {:?}", err),
            }
        }
    }

    ///Gets the affected function for the function failure error
    ///(CASS_ERROR_SERVER_FUNCTION_FAILURE) result type.
    pub fn function(&self) -> String {
        unsafe {
            let mut name = mem::zeroed();
            let mut length = mem::zeroed();
            match cass_error_result_function(self.0, &mut name, &mut length) {
                CASS_OK => {
                    let slice = slice::from_raw_parts(name as *const u8, length as usize);
                    str::from_utf8(slice).unwrap().to_owned()
                }
                err => panic!("impossible: {:?}", err),
            }
        }
    }

    ///Gets the number of argument types for the function failure error
    ///(CASS_ERROR_SERVER_FUNCTION_FAILURE) result type.
    pub fn num_arg_types(error_result: CassErrorResult) -> u64 {
        unsafe { cass_error_num_arg_types(error_result.0) }
    }

    ///Gets the argument type at the specified index for the function failure
    ///error (CASS_ERROR_SERVER_FUNCTION_FAILURE) result type.
    pub fn arg_type(&self, index: u64, arg_type: &str) -> u32 {
        unsafe {
            let cstr = CString::new(arg_type).unwrap();
            cass_error_result_arg_type(self.0,
                                       index,
                                       &mut cstr.as_ptr(),
                                       &mut (cstr.to_bytes().len() as u64)) as u32
        }
    }
}
impl Drop for CassErrorResult {
    fn drop(&mut self) {
        unsafe { cass_error_result_free(self.0) }
    }
}

impl CassError {
    fn pointer_to_string<'a>(c_buf: *const i8) -> &'a str {
        let buf: &[u8] = unsafe { CStr::from_ptr(c_buf).to_bytes() };
        str::from_utf8(buf).unwrap()
    }

    ///Gets the textual description for this error
    pub fn desc<'a>(&'a self) -> &'a str {
        unsafe {
        	panic!("");
//            match *self {
//                CassError::Lib(ref err) => CassError::pointer_to_string(cass_error_desc(err.err)),
//                CassError::Ssl(ref err) => CassError::pointer_to_string(cass_error_desc(err.0)),
//                CassError::Server(ref err) => CassError::pointer_to_string(cass_error_desc(err.0)),
//                CassError::Rust(ref err) => {
//                    match err {
//                        &CassRustError::NulInString(_) => "Tried to create a CString with a nul in the middle",
//                        /// /FIXME how do i return a slice created from self?
//                        &CassRustError::BadAddress(_) => "Tried to parse an invalid ip address",
//                    }
//                }
//            }
        }
    }
}
